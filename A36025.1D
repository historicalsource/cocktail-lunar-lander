	.TITLE	CTLINT - COCKTAIL LUNAR LANDER INT/TEST
;
;
;DIAGNOSTICS
;
	.RADIX	16
	.CSECT
	.GLOBL	NMI,PWRON,STEST,PWRINT,RAMTST,VRAMCLR,VRAMTST,ROMTST
	.GLOBL	D.SWTH,D.TEST,D.DIAG,RMCHAR,ROMDSP,D.FEND,D.FRME,D.DELY,T.FLAG
	.GLOBL	D.NEXT,LOADRAM,LODRM8,LODRM2,LODRM4,LDRAM,SCRLDO,SCRLOAD,SCRLD1,LDRAM4
	.GLOBL	SCRLD2,DIGITS,DIGT2S,DIGTYS,DECIMAL,DECCNV,BMNBLK

	.GLOBL	DIAGTBL,DTBLOFF,ROTR1

	.GLOBL	LEDS,VGON,TESTSW,NOISE,POTIN,WATCH,ENGMSG,E.MOFF,DIAG,THRKHZ,COIN1

	.GLOBL	RAMPTR,RAMLD,POINTR,TSFLAG,SWITCH,OLDSW,POTVAL,POTMIN
	.GLOBL	TEMP1,TEMP2,TEMP3,INDEX,TEST,ARRWX,ARRWY,$LMTIM,OFFSET
	.GLOBL	SOFT.0,SOFT.1,VGCOUNT,D.SCNT,PTRTMP
	.GLOBL	PTRNGE,POTUSE,INTCNT,INTFLG,GAMODE,TIMVAL,TIMER,FLMIN,POTFLG
	.GLOBL	GMTIME,VGCOUNT,TEMP6,NUMB1,NUMB2,NUMB3,LABPTR,FRAME,C.OPT,M2.OPT
	.GLOBL	DELX,DELY,SCROLL,SCRADD

	.GLOBL	START,DSPLAA,VGHEXZ,VGADD,MOOLAH,DSPATTR,MESSAGE,MESSRG,MESSFU,MESSLAB,C.MEC2

	.GLOBL	SELLED,PLSLCT,STRT1,THRSND,THRPTH,TONE
	.GLOBL	INITSTK,SOFTWD,FRMECNT,CNCNTR,FLFACT,SECCNT,PLAYER
;
	VGRAM	=^H4000		;VG RAM START
	VGROM	=^H4800		;VG RAM START
;
	FINI	=^H4BDE		;BEAM REST LABS & HALT
;
	MSSGLBS	=05A8E		;MESSAGE LABS' TABLE
	WAIT7	=0554C
	VGMSGA	=05786
	COPY	=055A0
;
	MINTST	=2		;ALPHA ROM #
	LASTST	=4		;NUMBER OF VG DIAG TESTS
;
OPT0	=2800
OPT1	=2801
OPT2	=2802
OPT3	=2803
;
	.SBTTL	.ASCVG - VG MODIFIED 'ASCII'
;
;MACRO .ASCVG CONVERTS STRING OF ALPHANUMERICS TO OFFSET VALUES INTO
;VGMSGA TABLE (TABLE OF VG CHARACTER JSRL'S)
;
	.MACRO .ASCVG .STRING
	.NCHR ..N,<.STRING>
	.IRPC ..C,<.STRING>
	.IF EQ,''..C-^H20
	..X=0			;BLANK CHAR=0
	.IFF
	.IF GT,''..C-^H40
	..X=''..C-^H36		;ALPHA'S ^B TO ^25
	.IFF
	..X=''..C-^H2F		;NUMBERS 1 TO ^A
	.ENDC
	.ENDC
	..X=..X*2		;..X=VGMSGA TABLE OFFSET
	..N=..N-1
	.IIF EQ,..N,..X=..X!^H80
	.BYTE ..X
	.ENDR
	.ENDM
	.LIST	MEB
	.NLIST	BYT
	.PAGE
	.INCLUDE VECMAC		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	.TITLE	CTLINT - COCKTAIL LUNAR LANDER INTERRUPT
;
	.SBTTL	CHKSUM #11 (7800-7BFF) [08]
	.BYTE 0
;
	.SBTTL	PROGRAM SOUNDS, LEDS
;
C.MEC2:	LDA	A,OPT3		;COIN MECH #2 SELECT
	AND	I,3
	TAX			;X = TABLE OFFSET
	LDA	AX,CM2TBL	;ACC = MECH #2 COIN SELECT
	STA	M2.OPT		;M2.OPT = MECH #2 COIN SELECT
	SEC
	LDA	A,OPT1		;XXXXXX43 OPTIONS
	ROL
	ROL
	AND	A,OPT0		;XXXX4321 COIN OPTIONS
	AND	I,0F
	ADC	I,0		;ADD ONE (CARRY SET)
	CMP	I,09		;FREE PLAY ? (BIT 4 SET)
	BCC	5$		;NO
	LDA	I,0		;ELSE = 0 (FREE PLAY)
5$:	STA	C.OPT		;COIN OPTION
	RTS
;
;COIN MECH #2 OPTIONS
;
CM2TBL:	.BYTE	1,4,5,6
;
;DISPLAY ATTRACT MESSAGE
;
DSPATTR:LDA	FRAME
	AND	I,20		;FLASH 'INSERT COINS'
	BEQ	20$
	LDX	I,0		;LABS OFFSET
	LDA	I,4		;'INSERT...'
10$:	JSR	MESSAGE		;LOAD LABS, WAIT & MESSAGE
20$:	LDA	I,COPY&0FF00/100
	LDY	I,COPY&0FF
	JSR	LODRM2
	LDA	A,OPT2
	LSR
	BCC	DSPAT0
	LDA	I,42.
	LDX	I,040
	JSR	MESSAGE
DSPAT0:	LDX	I,12.		;LABS FOR MESSAGE (NO FLASH)
	LDA	C.OPT		;ACC=COIN OPTION (* 2)
	CLC
	ADC	I,28.		;GET C.OPTION MESSAGE #
	JSR	MESSAGE		;LOAD LABS, WAIT & MESSAGE
	LDA	I,27.
	JSR	MESSRG		;DISPLAY FUEL UNITS
	LDA	I,5
	JMP	MESSRG
;
;	CONVERTS HEX INTO DECIMAL - 2 BYTE HEX IN X & Y
;	RESULT IN NUMB3,NUMB2,NUMB1
;
;
;	ROUTINE FOR FAST 16-BIT BINARY TO 6 DIGIT CONVERSION
;	INPUT:	X=MSB'S, Y=LSB'S
;	OUTPUT:	A=LSD'S, X=MIDDLE, Y=MSD'S
;	729. CYCLES WORST (AND BEST) CASE FOR 16. BITS
;
DECIMAL:STY	TEMP1		;TEMP1+1,TEMP1 = BINARY WORD
	LDY	I,15.		;BIT COUNT
DECCNV:	STX	TEMP1+1
	LDA	I,0
	STA	NUMB1		;CLR DECIMAL BYTES
	STA	NUMB2
	STA	NUMB3
	SED			;SET DECIMAL MODE
10$:	ASL	TEMP1
	ROL	TEMP1+1		;SHIFT A BIT OUT OF THE BINARY WORD
	LDA	NUMB1
	ADC	NUMB1
	STA	NUMB1		;AND ADD INTO DECIMAL BYTES
	LDA	NUMB2
	ADC	NUMB2
	STA	NUMB2
	ROL	NUMB3
	DEY
	BPL	10$
	LDY	NUMB3
	LDX	NUMB2
	LDA	NUMB1
	CLD			;CLEAR DECIMAL FLAG
	RTS
;
;ALPHANUMERIC STRING DISPLAY
;ENTRY	- POINTR = ALPHA STRING (.ASCVG)
;	  RAMPTR = ADDR. IN VGRAM FOR LOADING CHAR JSRL'S
;ASSUMES CHARACTER SIZE IS DEFAULT
;ALL CHARACTERS IN STRING ARE DISPLAYED ( ,1-9,A-Z)
;# OF CHARACTER <- 127.
;EXIT	- RAMPTR = ADDR. NEXT BYTE IN VGRAM
DSPLAA:	STX	POINTR+1	;ASCVG SOURCE POINTER
	STY	POINTR
DSPLAY:	LDA	I,0		;RAMPTR INDEX
10$:	LSR
	TAY
	LDA	NY,POINTR
	STA	TEMP3		;ASCVG REP.
	AND	I,7F
	TAX
	TYA
	ASL
	TAY
	LDA	AX,VGMSGA		;INSERT CHAR. JSRL INTO
	STA	NY,RAMPTR		;VGRAM
	INY
	LDA	AX,VGMSGA+1
	STA	NY,RAMPTR
	INY
	TYA
	BIT	TEMP3
	BPL	10$			;DO NEXT CHARACTER
	CLC			;EXIT W/RAMPTR = NEXT BYTE IN VG RAM LIST
	ADC	RAMPTR
	STA	RAMPTR
	BCC	50$
	INC	RAMPTR+1
50$:	TYA
	LSR				;CARRY IS CLEARED
	ADC	POINTR			;SET POINTR TO NEXT BYTE
	STA	POINTR
	BCC	60$
	INC	POINTR+1		;ADD IN CARRY
60$:	RTS
;
;	MESSAGE TAKES MESSAGE # (IN ACC) AND PUTS IN VG RAM
;	X = LABS # (OFFSET IN MSSGLBS)
;
;	LABS (BY X) AND WAIT INSERTED IN VG RAM FOLLOWED
;	BY MESSAGE STRING (OFFSET IN ACC)
;
;	ALL REGS USED; LODRM4, SCRLD2, & DSPLAA ROUTINES CALLED
;
MESSFU:	LDA	I,27.		;FUEL UNITS
	JSR	MESSRG
	LDA	I,3.		;LOST 
	BNE 	MESSRG		;ALWAYS
MESSLAB:LDA	I,80		;NO MESSAGE
;
MESSAGE:PHA			;SAVE MESSAGE #
	TXA
	CLC
	ADC	I,MSSGLBS&0FF
	TAY
	LDA	I,MSSGLBS/100
	ADC	I,0
	LDX	RAMPTR		;SAVE POINTER
	STX	LABPTR		;IN CASE OF LANDING OR OPTION
	LDX	RAMPTR+1	;MESSAGES
	STX	LABPTR+1
	JSR	LODRM4		;LOAD LABS (4 BYTES)
	JSR	SCRLD2		;LOAD WAIT (4 BYTES)
	PLA			;ACC = MESSAGE #
	BMI	MESSEXT		;BRANCH - NO STRING TO DISPLAY
MESSRG:	PHA			;SAVE MESSAGE #
	SEC
	SBC	I,9
	CMP	I,16.
	BCS	4$		;NOT A CRASH MESSAGE
	TAX
	LDA	AX,E.MOFF	;X POSITION OFFSET
	CLC
	LDY	I,2		;THIRD BYTE IS X POSITION
	ADC	NY,LABPTR	;LOWER X POSITION BYTE
	STA	NY,LABPTR
	LDA	I,0
	INY
	ADC	NY,LABPTR	;ADD IN CARRY TO TOP BYTE
	STA	NY,LABPTR
4$:	PLA			;RETRIVEVE MESSAGE #
	ASL			;ACC = MESSAGE # * 2
10$:	TAX
	LDY	AX,ENGMSG	;GET ENGLISH MESSAGE POINTER
	LDA	AX,ENGMSG+1
	TAX
	JMP	DSPLAA		;DISPLAY MESSAGE [X,Y = POINTER]
MESSEXT:RTS
;
	.PAGE
	.SBTTL	NMI
;
;	INTERRUPT OCCURS EVERY 4 MS. [FROM HARDWARE]
;
NMI:	PHA			;SAVE REGISTERS
	TXA
	PHA
	TYA
	PHA
	CLD
	BIT	T.FLAG
	BPL	1$
	JMP	NMEXIT
;
;POT CONVERSION ROUTINE
;
	ASL	POTFLG		;HAS POT BEEN SWITCHED?
1$:	BCS	NMTIME		;YES
	LDA	A,POTIN		;GET POT READING
	LDX	PLAYER
	SEC			;A = POT READING
	SBC	ZX,POTMIN	;CHK MIN
	BCS	10$		;BRANCH > MIN
	DEC	ZX,POTMIN	;LOWER MIN
	LDA	I,0
10$:	CMP	ZX,PTRNGE	;CHK RANGE
	BCC	20$		;BRANCH - WITHIN
	INC	ZX,PTRNGE	;INCREASE RANGE
	LDA	ZX,PTRNGE
20$:	TAY
	SEC
	SBC	ZX,POTVAL
	BCC	40$		;CHECK -3 IF BORROW
	LSR			;ELSE CHECK +3
	LSR
	BEQ	NMTIME		;NO CHANGE
30$:	STY	ZX,POTVAL	;UPDATE POT VALUE
	INC	ZX,POTUSE
	BNE	NMTIME		;ALWAYS
40$:	ADC	I,3		;CARRY IS CLR
	BMI	30$		;BEYOND NOISE

NMTIME:	INC	INTCNT		;INCREMENT INT (4 MS) COUNTER
	LDA	INTFLG		;CHK FRAME(S)
	CMP	I,3
	BCS	1$		;60 MS W/O FRAME
	LDA	SOFT.0		;CHK RAM 'WATCH' LOCATIONS
	EOR	SOFT.1
	EOR	SOFT.1+1
	CMP	I,SOFTWD
	BEQ	2$		;BRANCH IF OK
1$:	JMP	1$		;WAIT FOR WATCHDOG TO RESTART
2$:	STA	A,WATCH		;CLR WATCHDOG
	JSR	MOOLAH		;COIN ROUTINE
	LDA	I,0
	BCC	3$
	LDA	I,CNCNTR	;SET COIN COUNTER
3$:
	ORA	STRT1
	ORA	PLSLCT
	ORA	SELLED
	STA	A,LEDS		;SET LEDS
	LDA	TONE
	ORA	THRSND
	ORA 	THRPTH
	LDX	$LMTIM		;SLAM SWITCH
	BEQ	5$
	LDA	I,03F
5$:	STA	A,NOISE		;ALL SOUNDS FOR SLAM SWITCH
	BIT	GAMODE
	BVC	14$		;BRANCH - NOT PLAY
	LDA	GAMODE
	LSR
	BCS	14$		;NO COUNT IN FREEZE
	DEC	TIMVAL		;COUNT TIME IN PLAY MODE
	BNE	14$
	LDA	I,SECCNT
	STA	TIMVAL
	INC	TIMER		;COUNT GAME SECONDS
	SED
	CLC
	LDX	I,0
	LDY	I,2
	LDA	I,FLFACT
10$:	ADC	ZX,FLMIN
	STA 	ZX,FLMIN
	LDA	I,0
	INX
	DEY
	BPL 	10$
11$:	LDA	GMTIME		;GAME PLAY TIME
	CLC
	ADC	I,1
	CMP	I,60
	BCC	12$
	LDA	I,0
12$:	STA	GMTIME
	LDA	GMTIME+1
	ADC	I,0		;ADD 1 (IF CARRY SET)
	STA	GMTIME+1
14$:	CLD			;CLEAR DECIMAL MODE
	DEC	VGCOUNT		;CHK FOR EOF [END OF FRAME]
	BNE	NMEXIT
	LDA	I,FRMECNT
	STA	VGCOUNT		;RESET FRAME COUNT
	INC	INTFLG		;FRAME SYNC [EVERY 24MS]
NMEXIT:	PLA			;RESTORE REGISTERS
	TAY
	PLA
	TAX
	PLA
	RTI
	.PAGE
	.SBTTL	DISPLAY DIGITS
;
;DIGITS - DISPLAY 2Y DIGIT NUMBERS
;
;ENTRY	(C) = CARRY SET FOR ZERO SUPPRESSION
;	(A) = ADDRESS OF (Y) ZERO PAGE LOCATIONS CONTAINING NUMBER (LSB TO MSB)
;	(Y) = NUMBER OF ZERO PAGE LOCATIONS TO USE (1 TO 256).
DIGT2S:	LDY	I,2
DIGTYS:	SEC
DIGITS:	PHP			;SAVE INPUT PARAMETERS
	DEY
	STY	TEMP1+1
	CLC
	ADC	TEMP1+1
	PLP
	TAX			;MSB OF DIGITS
10$:	PHP
	STX	TEMP1		;SAVE DIGIT ZP OFFSET
	LDA	ZX,0
	LSR
	LSR
	LSR
	LSR
	PLP
	JSR	VGHEXZ		;FIRST DIGIT
	LDA	TEMP1+1
	BNE	20$
	CLC			;DISPLAY LAST DIGIT (EVEN 0)
20$:	LDX	TEMP1
	LDA	ZX,0
	JSR	VGHEXZ		;SECOND DIGIT
	LDX	TEMP1
	DEX
	DEC	TEMP1+1
	BPL	10$		;LOOP FOR EACH SET OF DIGITS
	RTS
	.PAGE
	.SBTTL	POWER ON & SELF TEST ROUTINES
;
;
;
PWRON:	LDX	I,INITSTK
	TXS			;INITIALIZE STACK
STEST:	CLD			;CLEAR DECIMAL MODE
	LDA	I,0
	STA	A,NOISE		;CLC NOISE
	TAX
10$:	STA	ZX,0		;CLEAR ZERO PAGE
	INX
	BNE	10$
	LDA	A,TESTSW	;BIT 1=SELF TEST
	BPL	PWRINT		;CONTINUE POWER ON
	JMP	RAMTST		;CONTINUE SELF TEST
PWRINT:	LDA	I,SOFTWD	;INITIALIZE SOFTWARE WATCHDOG BYTES TO OBSCURE VALUE
	STA	SOFT.0
	STA	SOFT.1
	STA	SOFT.1+1
	LDA	I,0FC
	STA	POTMIN		;INITIALIZE POT. MIN.=0FC
	STA	POTMIN+1	;PLAYER 2
	LDA	I,FRMECNT
	STA	VGCOUNT		;FRAME=24.MS (4 MS. * 6)
	LDA	I,2
	STA	ARRWX		;INITIALLY NO VELOCITY ARROWS
	STA	ARRWY
	STA	A,WATCH		
	JMP	START		;GO TO ATTRACT
;
;
;
	.SBTTL	ZERO-PAGE TEST
RAMTST:	LDX	I,11		;BEGINNING PATTERN
	TXS			;S HOLDS PATTERN
	TXA
	STA	Z,0		;TEST CELL START @ 0
	LDY	I,0
2$:	LDX	I,1		;ONE LESS COUNT BEFORE IT WRAPS
3$:	INY			;SCAN FORWARD
	LDA	AY,0		;ZERO ?
	BNE	6$		;NO - ERROR (HIGH BITS BAD)
	INX			;CHK HOW FAR SCANNED
	BNE	3$		;BRANCH - CONTINUE
	TSX
	TXA			;ACC = PATTERN
	STA	A,WATCH		;WATCHDOG
	INY			;POINT TO TEST CELL
	CMP	AY,0		;DOES IT HAVE PATTERN ?
	BNE	5$		;N0 - BRANCH (ERROR) (NOT (PATTERN) BITS BAD)
	LDX	I,0
	STX	ZY,0		;ELSE - CLEAR CELL
	INY			;POINT TO NEXT TEST CELL
	BNE	4$		;IF PASS NOT COMPLETE
	ASL			;ELSE SHIFT PATTERN
	LDX	I,0
	BCS	7$		;BRANCH - DONE (GOOD)
4$:	TAX			;PATTERN -> X
	TXS			;	 -> S
	STX	ZY,0		;	 -> NEXT TEST CELL
	BNE	2$		;ALWAYS - REPEAT SCAN
5$:	EOR	AY,0		;HIGH BITS ARE BAD
6$:	TAX			;ANY HIGH BITS INDICATE BAD RAM
7$:	TXA
	LDY	I,0F		;ASSUME LOW NIBBLE IS GOOD
	AND	I,0F		;CHECK IT
	BEQ	8$		;BRANCH - LOW NIBBLE GOOD
	LDY	I,30		;ELSE - SET Y ACCORDINGLY
8$:	TXA
	LDX	I,0F		;ASSUME TOP NIBBLE IS GOOD
	AND	I,0F0		;CHECK IT
	BEQ	9$		;BRANCH - TOP NIBBLE GOOD
	LDX	I,30		;ELSE - SET X
9$:
	TYA
	TXS
	TAX
RT.LP:	STX	A,NOISE		;NOISE = LOWER NIBBLE STATUS
	LDY	I,12.		;Y = HIGH BYTE OF COUNTER
10$:	LDX	I,100.		;X = LOW BYTE OF COUNTER
11$:	BIT	A,THRKHZ
	BMI	11$		;BIT 6 (V FLAG) OF TESTSW = 3000 HZ SQUARE WAVE
12$:	BIT	A,THRKHZ
	BPL	12$
	STA	A,WATCH
	DEX
	BNE	11$		;INNER LOOP 255. * 333 US = 85 MS
	CPY	I,5
	BNE	13$
	STX	A,NOISE		;CLR NOISE
13$:	DEY
	BNE	10$		;OUTER LOOP 8 *  85 MS = 580 MS
	TAY			;TEST SIGN
	BMI	14$		;DONE
	ORA	I,80		;SET SIGN
	TSX
	BPL	RT.LP		;ALWAYS
14$:	CMP 	I,8F		;ACC=08F
	BNE	17$		;NO-BAD RAM
	TSX
	CPX	I,0F		;X=0F
	BEQ	18$		;YES- ZP RAM GOOD
17$:	STA	A,WATCH		;WATCHDOG
	JMP	17$		;LOCKUP - BAD ZP RAM
18$:	LDX	I,INITSTK
	TXS			;INITIALIZE STACK (USED IN ROM TESTS)
;
;	CLEAR VG RAM
;
VRAMCLR:JSR	D.RMPT		;0 TO BE STORED IN VG RAM CELLS
	TAY
				;Y = 0
10$:	STA	NY,RAMPTR	;CLR RAM
	INY
	BNE	10$		;CONTINUE FOR ENTIRE PAGE
	INC	RAMPTR+1	;INCREMENT FOR NEXT PAGE
	LDX	RAMPTR+1
	CPX	I,VGRAM/100+8	;CKH IF DONE - 8 PAGES OF VG RAM
	BCC	10$		;BRANCH - DO NEXT PAGE (Y=0, ACC=0)
;
;	VECTOR GEN RAM TEST
;
	.SBTTL	VG RAM TEST
VRAMTST:JSR	D.RMPT		;TEST CELL START @ VGRAM
1$:	LDA	I,11		;BEGINNING PATTERN
	STA	TEMP1		;TEMP1 HOLDS PATTERN
				;Y=0
	STY	TSFLAG		;CLEAR FLAG
	STA	NY,RAMPTR	;TEST CELL START
				;Y=0
2$:	TYA
	TAX			;X = TEST CELL OFFSET
3$:	INY			;SCAN FORWARD
	BEQ	4$		;BRANCH - FINISHED WITH PAGE
	LDA	NY,RAMPTR	;ZERO ?
	BNE	9$		;NO - ERROR
	BEQ	3$		;ALWAYS
4$:	TXA
	TAY			;Y POINTS TO TEST CELL
	LDA	TEMP1		;ACC = PATTERN
	STA	A,WATCH		;WATCHDOG
	CMP	NY,RAMPTR	;DOES IT HAVE PATTERN ?
	BNE	8$		;IF NOT - ERROR
	LDA	I,0
	STA	NY,RAMPTR	;CLEAR CELL
	LDA	TEMP1		;LOAD PATTERN
	INY			;POINT TO NEXT TEST CELL
	BNE	6$		;BRANCH - IF PASS NOT COMPLETE
	ASL			;ELSE SHIFT PATTERN
	BCS	7$		;BRANCH - IF DONE W/PAGE
6$:	STA	TEMP1		;SAVE PATTERN
	STA	NY,RAMPTR	;NEW TEST CELL
	BNE	2$		;ALWAYS - REPEAT SCAN
7$:	INC	RAMPTR+1	;POINT TO NEXT PAGE
	LDA	RAMPTR+1
	CMP	I,VGRAM/100+8	;CHECK FOR SCAN END (8 PAGES OF VG RAM)
	BCC	1$		;BRANCH - SCAN NEXT PAGE
	BCS	13$		;DONE - VGRAM OK
				;ERROR IN VG RAM
8$:	EOR	NY,RAMPTR	;SET BAD BITS HIGH
9$:	LDX	I,0		;HIGH BITS ARE BAD
	PHA
	AND	I,0F0		;CHK TOP BYTE
	BEQ	10$
	LDX	I,2		;X(BIT 1) = 1 IF TOP NIBBLE BAD
10$:	PLA
	AND	I,0F
	BEQ	11$
	INX			;X (BIT 0) = 1 IF LOW NIBBLE BAD
11$:	TXA
	LDX	RAMPTR+1
	CPX	I,VGRAM/100+4	;CHECK WHICH RAM
	BCC	12$		;LEAST RAM(S) [4000-43FF]
	ASL			;HIGH RAM(S) [4400-47FF]
	ASL
12$:	ORA	TSFLAG		;HIGH BITS INDICATE BAD RAMS
	STA	TSFLAG
13$:	LDA	I,3
	STA	INDEX		;RAM COUNTER
	CLC			;CARRY CLEAR FOR FIRST SHIFT
14$:	LDA	I,0F		;ASSUME GOOD RAM (THRUST)
	ROR	TSFLAG
	PHP			;SAVE CARRY
	BCC	15$
	LDA	I,30		;BAD RAM (TONES)
15$:	STA	A,NOISE
	LDY	I,80.
	JSR	D.DELY		;80 COUNTS WITH NOISE= 533 MS
	STX	A,NOISE		;CLR NOISE
	LDY	I,40.
	JSR	D.DELY		;40 COUNTS SILENT= 267 MS
	PLP
	DEC	INDEX
	BPL	14$
	ROR	TSFLAG		;BITS D7 TO D4 = RAM STATUS
20$:	STA	A,WATCH		;WATCHDOG
	BNE	20$		;LOCKUP - BAD VG RAM
;
;	ROM TEST
;
ROMTST:				;PROG STARTS ON EVEN PAGE
	LDA	I,VGROM/100	;HIGH ROM ADDRESS BYTE
	STA	POINTR+1	;HIGH ADDRESS POINTER
	JSR	D.RMPT
	STA	POINTR		;LOW ADDRESS POINTER
	STA	TSFLAG		;CLR ROM FLAG (0 = OK)
	STA	TEST		;CLR FLAG
	JSR	BMNBLK		;TO STOP BEAM BLANKING CKT
	LDY	I,0
	.=.-1
	.WORD	VGSELF
	.=.-1
	LDA	I,0
	.=.-1
	.ENABL	M68
	.WORD	VGSELF
	.=.-1
	.DSABL	M68
	LDX	I,V.SELF
	JSR	LOADRAM
	LDA	I,18.		;TABLE OFFSET FOR ROM MESSAGE LABS
	JSR	RMCHAR		;PUT LABS & WAIT INTO VG RAM
	LDX	I,51.		;52 PAGES OF ROM
	TXA			;SEED FOR L.R.C.
	ASL			;GET SOMETHING IN EACH NIBBLE (6E)
10$:	LDY	I,0
	STA	A,WATCH		;WATCHDOG
11$:	EOR	NY,POINTR	;LONGITUDINAL PARITY
	INY
	BNE	11$		;LOOP FOR 1 PAGE
	TAY			;SAVE LRC
	TXA
	AND	I,3		;2 LSB = 1K ROM
	CMP	I,1		;CLEAR CARRY IF END OF ROM
	TYA			;ACC = LRC
	BCS	23$		;BRANCH - STILL IN ROM
	BEQ	15$		;BRANCH - ROM OK (LRC = 0)
	STA	TSFLAG		;ELSE - SET FLAG (BAD ROM)
				;DISPLAY (ROM # IN X (*4))
	STX	TEMP3		;TEMP1 = ROM # (*4)
	LDA	I,48.
	SEC
	SBC	TEMP3
	LSR
	LSR
	STA	TEMP3+1		;TEMP3+1 = ROM #
	SEC
	SBC	I,MINTST	;CHECK FOR ALPHANUMERIC (VG) ROMS
	CMP	I,2		;ARE THEY GOOD ?
	BCS	12$		;YES (BRANCH)
	DEC	TEST		;ELSE MINUS TEMP6 (BIT 7 SET)
12$:	JSR	R.NUMB		;DISPLAY ROM #
	LDX	TEMP3		;X = PAGE COUNTER
15$:	LDA	POINTR+1	;RE-SEED FOR NEW ROM
	CMP	I,05B
	BNE	18$
	LDA	I,05F
	STA	POINTR+1
18$:
	TXA
23$:	INC	POINTR+1	;BUMP POINTR (NEXT PAGE)
	DEX			;COUNT PAGES
	BPL	10$
	LDX	TSFLAG
				;CHK ROM STATUS HERE
				;ROM OK IF X=0
	BEQ	24$		;ROMS OK
	BIT	TEST		;CHK ALPHANUM ROM STATUS
	BPL	25$		;BRANCH - OK
	LDA	I,VGRAM+18+V.SELF/100
	STA	RAMPTR		;RESET POINTER
	LDA	I,VGRAM+18+V.SELF&0FF
	STA	RAMPTR
	LDA	I,34.		;LOAD DISPLAY FOR BAD
	LDX	I,14.		;ALPHANUM ROM
	JSR	ROMDSP		;LOAD VG RAM
	JMP	25$
24$:	LDX	I,0
	.=.-1
	.ENABL	M68
	.WORD	ROMOK
	.DSABL	M68
	.=.-1
	LDY	I,0
	.=.-1
	.WORD	ROMOK
	.=.-1
	JSR	DSPLAA
25$:	LDA	I,0
	STA	INDEX		;CLR LAMP COUNTER
	STA	TEMP3		;CLR STATE COUNTER
	LDA	RAMPTR+1		;INITIALIZE VG RAM POINTER
	STA 	PTRTMP+1
	LDA	RAMPTR
	STA	PTRTMP
				;CONTINUE TO D.SWTH
;
;
D.SWTH:	LDX	I,6
10$:	LDA	AX,ROTR1		;D7=SWITCH BIT
	ASL				;CARRY=SWITCH BIT
	ROL	SWITCH			;ROLL BIT INTO SWITCH
	DEX
	BPL	10$			;CONTINUE FOR ALL 8 SWITCHES
	LDX	I,5
12$:	LDA	AX,COIN1
	ASL
	ROL	SWITCH+1
	DEX
	BPL	12$
	LDX	I,0			;ASSUME NO CHANGE
	LDA	OLDSW			;CHECK OLD SWITCH STATE
	EOR	SWITCH			;W/NEW
	BNE	15$
	LDA	OLDSW+1
	EOR	SWITCH+1
	BEQ	20$			;BRANCH - NO CHANGE
15$:	LDX	I,30			;ELSE - SET TONES
20$:
	STX	TONE
	LDA	SWITCH
	STA	OLDSW
	LDA	SWITCH+1
	STA	OLDSW+1
	LDA	I,0
	STA	SWITCH		;CLR SWITCHES
	STA	SWITCH+1
	LDA	PTRTMP
	STA	RAMPTR
	LDA	PTRTMP+1
	STA	RAMPTR+1
	BIT	TEST		;CHECK FOR BAD ALPHANUMERIC ROM
	BMI	22$		;BRANCH - ROM IS BAD
	LDA	I,26.			;LOAD LABS & WAIT
	JSR	RMCHAR		;LOAD LABS & WAIT (ACC IS OFFSET)
	LDY	I,1
	LDA	A,POTIN		;READ VALUE
	CLC
	ADC	POTVAL		;AVERAGE 2 READING
	ROR
	STA	POTVAL		;AND STORE IT
	TAX
	LDA	I,0
	STA	TEMP1
	LDY	I,7
	JSR	DECCNV
	LDA	I,NUMB1
	JSR	DIGT2S		;DISPLAY VALUE
	JSR	DSPAT0		;DISPLAY MECH OPTION IN PROPER LANG.
	LDA	I,30
	JSR	RMCHAR		;LABS & WAIT
	JSR	C.MEC2		;GET MECH 2 OPTION
	LDA	I,M2.OPT	;DISPLAY MECH #2 OPTION (FACTOR)
	LDY	I,1
	JSR	DIGTYS
	LDA	I,010
	LDX	I,2
	JSR	ROMDSP
	LDA	A,OPT2
	AND	I,1
	EOR	I,1
	STA	TEMP3
	LDA	I,TEMP3
	LDY	I,1
	JSR	DIGTYS
22$:	JSR	D.FEND		;PUT HALT IN VG RAM & DELAY FOR FRAME
	INC	INDEX			;COUNT FRAMES
	LDA	INDEX
	CMP	I,40		;CHECK FOR 64 FRAMES
	BCC	30$		;@ 64 FRAMES (1.250 SECONDS)
	LDX	TEMP3+1		;GO TO NEXT LAMP STATE
	INX
	CPX	I,5		;5 SOUND STATES
	BCC	25$
	LDA	PLSLCT
	EOR	I,8
	STA	PLSLCT
	LDX	I,0		;GO TO STATE 0
25$:	STX	TEMP3+1		;SET STATE
	STX	INDEX		;CLR INDEX (Y = 0)
30$:	LDX	I,0
	LDA	OLDSW
	ORA	OLDSW+1
	BEQ	32$
	LDX	I,13
32$:	TXA
	ORA	PLSLCT
	STA	A,LEDS
	LDX	TEMP3+1
	LDA	AX,S.STAB	;GET SOUND STATE
	ORA	TONE
	STA	A,NOISE
	JSR 	D.NEXT		;FRAME
	BCS	D.TEST
	JMP	D.SWTH			;CONTINUE UNTIL DIAG STEP
;
;D.TEST LOADS DIAGNOSTICS IN VG RAM AND STEPS THROUGH PER
;DIAG TEST SW (DEBOUNCED IN D.TEST)
;TESTS ARE:	DIAG1	DIAGONAL LINE
;		DIAG2	JSRL TEST (SUBROUTINES)
;
D.TEST:	LDX	I,0
	STX	A,NOISE		;CLR SOUNDS
	JSR	D.RMPT
D.DIAG:	STX	TEST		;DIAG TEST # (0 TO 3)
	LDY	AX,DTBLOFF
	LDA	I,0B0
	STA	NY,RAMPTR
	DEY
	DEY
5$:	LDA	AY,DIAGTBL
	STA	NY,RAMPTR
	DEY
	BPL	5$
;
10$:	JSR	D.FRME		;DELAY FRAME TME (= 20 MS)
	JSR	D.NEXT		;DEBOUNCE DIAG STEP SWITCH
	BCC	10$
	LDX	TEST
	INX
	CPX	I,LASTST	;CHK FOR LAST TEST
	BCC	D.DIAG		;EXECUTE NEXT TEST
	LDA	I,0
	STA	T.FLAG
	JMP	PWRINT		;END OF TESTS
;
;INITIALIZE RAMPTR
;
D.RMPT:	LDA 	I,VGRAM/100
	STA	RAMPTR+1
	LDA	I,VGRAM&0FF
	STA	RAMPTR
	RTS
;
;	LOAD BYTES INTO VG RAM FOR ROM STATUS DISPLAY
;		RAMPTR = POINTER INTO VG RAM
;		PVGTST = TABLE OF DISPLAY CHARACTERS ,LABS, & VCTRS
;	ENTER - X=# OF BYTES TO MOVE
;		A=OFFSET INTO PVGTEST
;	EXIT - RAMPTR = NEXT FREE BYTE
;	       ALL REGS BLITZED
;
RMCHAR:	LDX	I,8			;8 BYTES
ROMDSP:	CLC
	ADC	I,0
	.=.-1
	.WORD	R.LAB
	.=.-1
	TAY
	LDA	I,0
	.=.-1
	.ENABL	M68
	.WORD	R.LAB
	.DSABL	M68
	.=.-1
	ADC	I,0
	JMP	LOADRAM
;
;
;
D.FEND:	LDA	I,FINI/100		;BEAM REST LABS & HALT
	LDY	I,FINI&0FF
	LDX	I,6
	JSR	LOADRAM
D.FRME:	STA	A,VGON			;STROBE VG
					;DELAY = 20 MS (FRAME LENGTH)
	LDY	I,3			;Y=HIGH BYTE COUNTER
D.DELY:	STA	A,WATCH		;WATCHDOG
	LDX	I,20.			;X=LOW BYTE COUNTER
20$:	BIT	A,THRKHZ
	BMI	20$
30$:	BIT	A,THRKHZ
	BPL	30$
	DEX
	BNE	20$			;INNER LOOP: 200.*333US=6.67M
	DEY
	BNE	D.DELY			;OUTER LOOP: Y*6.67MS=
					;(FROM D.FRME = 20MS)
	RTS
;
;DEBOUNCE DIAG STEP SWITCH
;
D.NEXT:	BIT	A,TESTSW	;BIT 7=SELF TEST SWITCH (HIGH TRUE)
	BMI	20$		;PUSHED
	DEC	T.FLAG
	ASL	D.SCNT		;SHIFT BIT TO LEFT
10$:	RTS			;CARRY SET ON DEBOUNCE
20$:	LDA	I,20
	STA	D.SCNT		;INITIALIZE DEBOUNCE COUNTER
	LDA	I,0C0
	STA	T.FLAG
	CLC
	RTS			;ALWAYS (CARRY CLEAR=NO DEBOUNCE)
;
;
;LOADRAM MOVES BYTE FROM (RAMLD) TO
;(RAMPTR), X=# OF BYTES, Y,A = (LO),(HI) ADDR. TO LOAD FROM, AT EXIT
;RAMLD & RAMPTR POINT @ NEXT BYTE
;
LODRM8:	LDX	I,8		;STANDARD = 8 BYTES
LOADRAM:STA	RAMLD+1		;A,Y=HI,LO ADDR. OF SOURCE
	STY	RAMLD
LDRAM:	TXA			;ASSUMES RAMLD, RAMPTR ARE CORRECT
	TAY
	DEY
10$:	LDA	NY,RAMLD	;MOVE BYTES FROM RAMLD TO RAMPTR
	STA	NY,RAMPTR	;# OF BYTES =[X]
	DEY
	BPL	10$
	TXA
	CLC
	ADC	RAMPTR		;UPDATE RAMPTR
	STA	RAMPTR
	BCC	20$
	INC	RAMPTR+1
20$:	TXA
	CLC
	ADC	RAMLD		;UPDATE RAMLD
	STA	RAMLD
	BCC	30$
	INC	RAMLD+1
30$:	RTS			;EXIT RAMPTR=NEXT FREE BYTE
				;RAMLD = NEXT AVAILABLE BYTE
;
LODRM2:	LDX	I,2		;MOVE 2 BYTES RAMLD >> RAMPTR
	BNE	LOADRAM		;ALWAYS BRANCH
;
LODRM4:	LDX	I,4		;MOVE 4 BYTES
	BNE	LOADRAM		;ALWAYS BRANCH
;
LDRAM4:	LDX	I,4		;MOVE 4 BYTES (W/EXISTING POINTERS)
	BNE	LDRAM		;ALWAYS
;
SCRLDO:	CLC
	ADC	OFFSET		;ADD TABLE OFFSET TO POINTER (ACC & X)
	TAY
	TXA
	ADC	I,0
SCRLOAD:LDX	I,0		;CLEAR ROTATE VALUE
	STX	DELX
	LDX	I,0F
	STX	DELX+1		;CLEAR QUADRANT VALUE
SCRLD1:	STA	RAMLD+1		;RAMLD = SOURCE POINTER
	STY	RAMLD
	LDY	I,0
	LDA	NY,RAMLD
	SEC
	SBC	SCRADD+1	;DO Y AXIS SCROLLING
	STA	NY,RAMPTR
	INY
	LDA	NY,RAMLD
	SBC	SCRADD+2
	AND	I,0F
	ORA	I,0A0
	STA	NY,RAMPTR	;Y AXIS
	INY
	LDA	NY,RAMLD
	SEC
	SBC	SCROLL+1	;X AXIS SCROLLING
	STA	NY,RAMPTR
	INY
	LDA	NY,RAMLD
	SBC	DELX		;SUBTRACT ROTATE FACTOR
	AND	DELX+1		;SET QUADRANT
	STA	NY,RAMPTR
	JSR	VGADD		;UPDATE RAMPTR
SCRLD2:	LDA	I,WAIT7/100
	LDY	I,WAIT7&0FF
	JMP	LODRM4		;ADD IN LABS WAIT [AND RETURN]
;
;
;
R.NUMB:	LDX	I,0
	LDY	TEMP3+1		;CONVERT ROM # (TEMP3+1) INTO DECIMAL
	JSR	DECIMAL
				;NUMB1=ROM # (DECIMAL)
	LDA	I,NUMB1
	SEC			;NO LEADING ZEROS
	LDY	I,1		;DISPLAY 2 DIGITS
	JSR	DIGITS
	LDA	I,16.
	LDX	I,2
	JMP	ROMDSP		;PUT BLANK INTO VG RAM
;
;
;
BMNBLK:	LDA	I,0		;LABS FOR CORRECTING HARDWARE
				;BEAM BLANKING BUG
	LDX	I,10		;22. BYTES DOWN THE DRAIN
	JMP	ROMDSP		;LOAD TWO LABS & WAITS
;
R.LAB:	LABS	0,128.		;2 LABS GIVES HARDWARE THE
	WAIT	9		;IMPRESSION THAT THE BEAM IS MOVING
	LABS	1023.,895.	;BEYOND THE MINIMUM THRESHOLD
	WAIT	9
;
R.BLNK:	VCTR	24.,0,0		;BLANK SPACE
;
VGTLBS:	LABS	176.,600.	;LABS
	WAIT	7		;& WAIT
;
D.VGPT:	LABS	488.,480.	;BEAM POSITION
	WAIT	7			;BEAM WAIT
;
;
R.ALPH:	VCTR	48.,0,12.	;SQUARE (W/X)
	VCTR	0,-48.,12.
	VCTR	-48.,0,12.
	VCTR	0,48.,12.
	VCTR	48.,-48.,12.
	VCTR	-48.,0,0
	VCTR	48.,48.,12.
;
R.OPT:	LABS	470.,378.
	WAIT	7
;
;
ROMOK:	.ASCVG	<ROM OK>
;
S.STAB:	.BYTE	1,3,7,0F,0		;SOUND STATES
	.PAGE
	.RADIX	10
	.SBTTL	VG DIAG TEST ROUTINES
	.BRITE=7
;
;
VGSELF:	LABS 0,128
	WAIT 7
	VCTR 1023,0,.BRITE	;EDGE OF SCREEN
	VCTR 0,767,.BRITE
	VCTR -1023,0,.BRITE
	VCTR 0,-767,.BRITE
	VCTR 767,767,.BRITE	;DRAW 45 DEGREE
	VCTR 256,-256,.BRITE
	VCTR -511,-511,.BRITE
	VCTR -512,512,.BRITE
	VCTR 256,255,.BRITE
	VCTR 767,-767,.BRITE
	VCTR 0,767,0		;1023,895
	VCTR -767,-767,.BRITE
	VCTR -256,255,.BRITE
	VCTR 512,512,.BRITE
	VCTR 511,-511,.BRITE
	VCTR -256,-256,.BRITE
	VCTR -767,767,.BRITE
	VCTR 488,-391,0		;488,512
	VCTR 48,0,13
	VCTR 0,4,0
	VCTR -48,0,12
	VCTR 8,4,0
	VCTR 32,0,11
	VCTR 0,4,0
	VCTR -32,0,10
	VCTR 4,4,0
	VCTR 24,0,9
	VCTR 0,4,0
	VCTR -24,0,8
	VCTR 4,4,0
	VCTR 16,0,7
	VCTR 0,4,0
	VCTR -16,0,6
	VCTR 2,4,0
	VCTR 12,0,5
	VCTR 0,4,0
	VCTR -12,0,4
	VCTR 2,4,0
	VCTR 8,0,3
	VCTR 0,4,0
	VCTR -8,0,2
;
V.SELF	=.-VGSELF
;
.DIAG	=7
;
;
DTBLOFF:.BYTE	13,23,29,51
;
DIAGTBL:LABS	0,128
	WAIT	7
	VCTR	1023,767,.DIAG
	LABS	560,464		;SHORT VECTOR TEST
	WAIT	7
	VCTR	-48,48,.DIAG
	JMPL	1$-DIAGTBL	;JMPL TEST
	HALT			;(FAILURE=HALT)
1$:	VCTR	-32,32,.DIAG
	JSRL	2$-DIAGTBL	;JSRL TEST
	VCTR	0,-32,.DIAG
	HALT
2$:	JSRL	3$-DIAGTBL
	RTSL
3$:	JSRL	4$-DIAGTBL
	RTSL
4$:	JSRL	5$-DIAGTBL
	RTSL
5$:	VCTR	32,0,.DIAG
	RTSL
;
	.NLIST
	.REPT 75.
	.WORD 0			;BLANK FILL (FOR VCTRS)
	.ENDR
	.LIST
;
;INTERRUPT VECTORS
;
	.SBTTL	CHKSUM #12 (7C00 - 7FFF) [04]
	.VCTRS	^H7FF8,0	;CHKSUM
;
	.VCTRS	^H7FFA,NMI	;NMI VECTOR
	.VCTRS	^H7FFC,PWRON	;RESET VECTOR
	.VCTRS	^H7FFE,PWRON	;IRQ VECTOR
;
	.END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      